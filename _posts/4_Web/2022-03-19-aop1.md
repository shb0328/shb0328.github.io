---
layout: "single"
title: "AOP"
categories: [Web]
tags: [AOP]
permalink : /aop/1
---
Aspect-Oriented Programming (AOP)

ê´€ì  ì§€í–¥ í”„ë¡œê·¸ë˜ë°

# ì™œ í•„ìš”í•œê°€?

## ğŸ˜•ì˜ˆë¥¼ ë“¤ì–´,

### ìš°ë¦¬ì˜ í”„ë¡œê·¸ë¨ êµ¬ì¡°ê°€ ë‹¤ìŒê³¼ ê°™ì„ ë•Œ, ëª‡ ê°€ì§€ ìš”êµ¬ì‚¬í•­ì„ ë°›ê²Œ ë˜ì—ˆë‹¤.

**Our Application Architecture**
![220319203008.png](/assets/images/220319203008.png)

Code for Data Access Object (DAO)

```java
public void addAccount(Account theAccount, String userId) {
	Session currentSession = sessionFactory.getCurrentSession();
	currentSession.save(theAccount);
}
```

### ìš”êµ¬ì‚¬í•­ 1 - Logging

DAO method ì‹¤í–‰ ì „ì— ë¡œê·¸ë¥¼ ë‚¨ê²¨ë¼!

- Need to add logging to our DAO methods
    - add some logging statements before the start of the method
    

Add Logging Code

```java
public void addAccount(Account theAccount, String userId) {

	// add code for logging

	Session currentSession = sessionFactory.getCurrentSession();
	currentSession.save(theAccount);
}
```

### ìš”êµ¬ì‚¬í•­ 2 - Security

DAO method ì‹¤í–‰ ì „ì— ë³´ì•ˆ ì¸ì¦ ì‘ì—…ì„ ì¶”ê°€í•´ë¼!

- Need to add security code to out DAO
    - Make sure user is authorized before running DAO method

Add Security Code

```java
public void addAccount(Account theAccount, String userId) {

	// add code for logging

	// add code for security check

	Session currentSession = sessionFactory.getCurrentSession();
	currentSession.save(theAccount);
}
```
### ìš”êµ¬ì‚¬í•­ 3 - ëª¨ë“  layerì— Logging, Security ì¶”ê°€...ğŸ˜‘

![220319202847.png](/assets/images/220319202847.png)

## Two Main Problems

- Code Tangling ë³µì¡í•œ ì½”ë“œ
    - For a given method : `addAccount(...)`
    - We have logging and security code tangled in
    - ì¦‰, `addAccount()` ëŠ” ì—¬ëŸ¬ê°œì˜ ì¼ì„ í•˜ê²Œ ëœë‹¤.
    - **í•µì‹¬ ë¡œì§ì˜ ëª¨ë“ˆí™” ë¶ˆê°€ëŠ¥**
- Code Scattering ë¶„ì‚°ëœ ì½”ë“œ
    - If we need to change logging or security code
    - We have to update ALL classes
    - **ì¦‰, ìœ ì§€ë³´ìˆ˜ê°€ ì–´ë ¤ì›Œì§„ë‹¤.**
    
### ê°€ëŠ¥í•˜ì§€ë§Œ ì—¬ì „íˆ ë¬¸ì œê°€ ì¡´ì¬í•˜ëŠ” Solutions

- Inheritance ìƒì† (is a)
    - Every class would need to inherit from a base class
    - Can all classes extends from your base class? ... plus no multiple inheritance
    - **ì¦‰, ë‹¤ì¤‘ ìƒì†ë„ ì•ˆë˜ëŠ”ë°, ëª¨ë“  í´ë˜ìŠ¤ê°€ ì–´ë–¤ base classë¥¼ ìƒì†ë°›ì„ ìˆœ ì—†ë‹¤.**
- Delegation ìœ„ì„ (has a)
    - Classes would delegate logging, security calls
    - Still would need to update classes if we wanted to
        - add/remove logging or security
        - add new feature like auditing, API management, instrumentation
    - **ëª¨ë“  í´ë˜ìŠ¤ì—ì„œ logging, security ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°€ì§€ê³  ìˆê²Œ ë˜ë©°, ê²°êµ­ ëª¨ë“  í´ë˜ìŠ¤ì— ì˜í–¥ë„ê°€ ìˆì–´ì„œ ìœ ì§€ë³´ìˆ˜ê°€ ì–´ë µê²Œ ëœë‹¤.**

-----

# ğŸ˜†ë‹µì€ AOP !!

ê³µí†µ ê´€ì‹¬ ì‚¬í•­ì„ ìº¡ìŠí™”í•˜ì.

- Programming technique based on concept of an Aspect
- Aspect encapsulates cross-cutting logic : Cross-Cutting Concerns (ê³µí†µê´€ì‹¬ì‚¬í•­)
 
## Terms

- **Aspect** : **module** of code for a cross-cutting concern (logging, security)
- **Advice** : **what** action is taken and when it should be applied
- **Join Point** : **when** to apply code during program execution
- **Pointcut** : a predicate expression for **where** advice should be applied
- **Weaving** : **Connecting** aspects to target objects to create an advised object

### ğŸ’›**Aspect**

ê³µí†µê´€ì‹¬ì‚¬í•­ì„ ëª¨ë“ˆí™” í•œ ê²ƒ

- Aspect can be reused at multiple locations
- applied **based on Configuration**

### ğŸ’›**Advice**

ì‹¤í–‰ë  ë¡œì§

- Advice Types
    - **Before** advice : run before the method
    - **After** (finally) advice : í•­ìƒ ì‹¤í–‰ run after the method (finally)
    - **After returning** advice : ì„±ê³µí•˜ë©´ ì‹¤í–‰ run after the method (success execution)
    - **After throwing** advice : ì‹¤íŒ¨í•˜ë©´ ì‹¤í–‰ run after method (if exception thrown)
    - **Around** advice : run before and after method

### ğŸ’›**Join Point** 

Aspect ê°ì²´ì—ì„œ ì‘ì„±í•œ ì½”ë“œ(Advice)ê°€ ì‹¤í–‰ë  ì‹œì  (when)

- exception-level : ì˜ˆì™¸(exception)ê°€ ë°œìƒë˜ëŠ” ì‹œì 
- field-level : í•„ë“œ(field)ê°€ ìˆ˜ì •ë˜ëŠ” ì‹œì 
- constructor-level : ê°ì²´ê°€ ìƒì„±(constructor)ë˜ëŠ” ì‹œì 
- method-level : íŠ¹ì • ë©”ì†Œë“œê°€ í˜¸ì¶œë˜ëŠ” ì‹œì 

### ğŸ’›**Pointcut** 

Aspect ê°ì²´ì—ì„œ ì‘ì„±í•œ ì½”ë“œ(Advice)ê°€ ì‹¤í–‰ë  ì§€ì  (where)

- **PointCut Designator (PCD)**
    - `execution`
    - `within`
    - `args`
    - `this`
    - `target`
    - `@target`
    - `@args`
    - `@within`
    - `@annotation`

### ğŸ’›**Weaving**

Aspect í´ë˜ìŠ¤ì— ì •ì˜í•œ Advice ë¡œì§ì„ Target ì— ì ìš©í•˜ëŠ” ê²ƒ

ì¦‰, ê³µí†µì½”ë“œ(advice)ë¥¼ í•µì‹¬ ë¡œì§ ì½”ë“œì— ì‚½ì…í•˜ëŠ” ê²ƒ

- Different types of weaving
    - compile-time
    - load-time
    - run-time (ê°€ì¥ ëŠë¦¼)
    
-----

# AOP Frameworks for Java

## ğŸ‘‰AspectJ

- Original AOP framework, released in 2001
- Provides **complete support** for AOP
- Rich support for
    - join points : **method-level, constructor-level, field-level**
    - code weaving : **compile-time, post compile-time, load-time**
    
## ğŸ‘‰Spring AOP

- Spring provides AOP support
- Key component of Spring
    - Security, transactions, caching etc
- Uses **run-time weaving** of aspects
- only **method-level**
- ê·¸ë¦¬ê³ , AspectJ jar ê°€ í•„ìš”í•˜ë‹¤

**Proxy design pattern**

![220319202715.png](/assets/images/220319202715.png)

- ***AOP proxy*** : an object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy will be a **JDK dynamic proxy or a CGLIB proxy.**
- ìš”ìƒŒ ê±°ì˜ CGLIB proxyë§Œ ì“°ëŠ” ê²ƒ ê°™ë‹¤ê³  í•¨

![220319202247.png](/assets/images/220319202247.png)

## ğŸ§Spring AOP vs AspectJ

|  | Spring AOP | AspectJ |
| --- | --- | --- |
| pointcut syntax | simple | complex |
| join point | only method-level | all |
| weaving | run-time | compile-time / post compile-time / load-time |
| performance | slower | faster |
| dependency | need AspectJ jar (migration) | . |
| work with | Beans Created by application context | any POJO |
| design pattern | proxy pattern | . |

-----

# Test Example

1. create target object

```java
@Component
public class AccountDAO() {
	public void addAccount() {
		System.out.println(">> DB Work :: insert account data");
	}
}
```

2. create spring java config class

```java
@Configuration
@EnableAspectJAutoProxy //AspectJ ë¥¼ ì´ìš©í•´ì„œ Spring AOP ë¥¼ ì‚¬ìš©í•˜ì—¬ë°±ê·¸ë¼ìš´ë“œì—ì„œ Proxy ì‚¬ìš©
@ComponentScan("com.example.aop")
public class ExConfig {

}
```

3. create main app

```java
public class MainApp {

	public static void main(String[] args) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ExConfig.class);
		AccountDAO dao = context.getBean("accountDAO", AccountDAO.class);
		dao.addAccount();
		context.close();
	}

}
```

4. create an aspect with `@Before` advice

```java
@Aspect //org.aspectj.lang.annotation.Aspect
@Component
public class MyLoggingAspect { //aspect
	
	//advice
	@Before("execution(public void addAccount())") //pointcut
	public void beforeAddAccountAdvice() {
		System.out.println("I'm @Before advice !!!") 
	}
}
```

5. result

```bash
I'm @Before advice !!!
>> DB Work :: insert account data
```

-----


### âœ…Benefits of AOP

- Code for Aspect is defined in a single class 
**ì½”ë“œê°€ ì¤‘ë³µ/ë¶„ì‚°ë˜ì§€ ì•ŠëŠ”ë‹¤. (Not scattered)**
    - Much better than being scattered everywhere
    - Promotes code reuse and easier to change
- Business code in your application is cleaner 
**í•µì‹¬ ë¡œì§ì„ ê¹”ë”í•˜ê²Œ ì‘ì„±í•  ìˆ˜ ìˆë‹¤. (Not Tangled)**
    - Only applies to business functionality : `addAccount`
    - Reduces code complexity
- Configurable
**MainApp ì½”ë“œë¥¼ ë³€ê²½í•  í•„ìš”ì—†ì´, Configuration ìœ¼ë¡œ ì„ íƒì  ì ìš© ê°€ëŠ¥**
    - Based on configuration, apply Aspects selectively to different parts of app
    - No need to make changes to main application code ... very important!

### âœ…Advantages

- ì¬ì‚¬ìš©ì„± ì¦ê°€ : Reusable modules
- tangling/scatter í•´ê²° : Resolve code tangling/scatter
- ì„ íƒì  ì ìš© : applied selectively based on configuration

### âœ…Disadvantages

- ë””ë²„ê¹… ì–´ë ¤ì›€ : too many aspects and app flow >> hard to flow
- ë¹„ìš© ì¦ê°€ : minior performance cost for aspect execution (run-time weaving)

### âœ…Use Cases

- Most common
    - **logging, security, transactions**
- Audit logging
    - who, what, when, where
- Exception handling
    - **log exception and notify** DevOps team via SMS/email
- API Management
    - how many times has a method been called user
    - **analytics : peak times, average load, top user**

---

> Reference
  - Udemy 
    - Spring 5: Learn Spring 5 Core, AOP, Spring MVC, Spring Security, Spring REST, Spring Boot 2, Thymeleaf, JPA & Hibernate by Chad Darby
  - Docs
    - [Chapter 6. Aspect Oriented Programming with Spring](https://docs.spring.io/spring-framework/docs/2.5.x/reference/aop.html)
    - [Pointcuts](https://www.eclipse.org/aspectj/doc/next/progguide/semantics-pointcuts.html)
  - Blogs
    - [https://nankisu.tistory.com/6](https://nankisu.tistory.com/6)
    - [AOP ë€ ë¬´ì—‡ì¸ê°€?](https://seulkom.tistory.com/18)
    - [Spring AOP (ê°œë…, ìš©ì–´, ì›ë¦¬, í¬ì¸íŠ¸ì»· í‘œí˜„ì‹, JoinPoint API)](https://sjh836.tistory.com/157)
    - [[Java] ìƒì†(Inheritance) vs ìœ„ì„(Delegation)](https://sorjfkrh5078.tistory.com/282)
    - [weavingì´ë€ ë¬´ì—‡ì¸ê°€?](https://lifedeveloper.tistory.com/entry/weaving%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)